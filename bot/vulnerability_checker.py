"""
Vulnerability checker for trading bot
Identifies potential issues and edge cases
"""
import MetaTrader5 as mt5

class BotVulnerabilityChecker:
    """Checks for common trading bot vulnerabilities"""
    
    def __init__(self, log):
        self.log = log
        self.issues = []
    
    def check_multiple_entries(self, symbol: str, positions: list, magic: int) -> bool:
        """
        VULNERABILITY: Multiple open positions on same symbol
        Risk: Conflicts, double SL/TP updates, uncontrolled drawdown
        """
        auto_pos = [p for p in positions if p.magic == magic]
        if len(auto_pos) > 1:
            self.issues.append(f"⚠️ MULTIPLE ENTRIES: {symbol} has {len(auto_pos)} bot positions (ticket={[p.ticket for p in auto_pos]})")
            return False
        return True
    
    def check_invalid_sl_tp(self, position, symbol: str) -> bool:
        """
        VULNERABILITY: SL == Entry or TP == Entry (no risk/reward)
        Risk: Trades instantly close or never profit
        """
        entry = float(position.price_open)
        sl = float(position.sl)
        tp = float(position.tp)
        
        if abs(sl - entry) < 0.0001:  # SL at entry
            self.issues.append(f"⚠️ INVALID SL: {symbol} ticket={position.ticket} SL==Entry={entry:.5f}")
            return False
        
        if abs(tp - entry) < 0.0001:  # TP at entry
            self.issues.append(f"⚠️ INVALID TP: {symbol} ticket={position.ticket} TP==Entry={entry:.5f}")
            return False
        
        return True
    
    def check_sl_tp_conflict(self, position, symbol: str) -> bool:
        """
        VULNERABILITY: SL >= TP (buy) or SL <= TP (sell)
        Risk: Trade locked with conflicting price targets
        """
        entry = float(position.price_open)
        sl = float(position.sl)
        tp = float(position.tp)
        
        if position.type == mt5.POSITION_TYPE_BUY:
            if sl >= tp:  # For buy, SL should be < TP
                self.issues.append(f"⚠️ SL/TP CONFLICT BUY: {symbol} ticket={position.ticket} SL={sl:.5f} >= TP={tp:.5f}")
                return False
        else:  # SELL
            if sl <= tp:  # For sell, SL should be > TP
                self.issues.append(f"⚠️ SL/TP CONFLICT SELL: {symbol} ticket={position.ticket} SL={sl:.5f} <= TP={tp:.5f}")
                return False
        
        return True
    
    def check_excessive_sl(self, position, symbol: str, account_balance: float) -> bool:
        """
        VULNERABILITY: SL distance > 5% of entry (excessive risk on single trade)
        Risk: Drawdown too large for single trade
        """
        entry = float(position.price_open)
        sl = float(position.sl)
        risk_pips = abs(sl - entry)
        risk_pct = (risk_pips / entry) * 100
        
        if risk_pct > 5.0:  # More than 5% risk
            self.issues.append(f"⚠️ EXCESSIVE SL: {symbol} ticket={position.ticket} risk={risk_pct:.2f}% of entry")
            return False
        
        return True
    
    def check_signal_alignment(self, signal_side: str, trend: int, symbol: str) -> bool:
        """
        VULNERABILITY: Signal direction conflicts with trend
        Risk: Trading against the trend = higher probability of loss
        """
        trend_name = "BULLISH" if trend == 1 else "BEARISH"
        
        if signal_side == "BUY" and trend != 1:
            self.issues.append(f"⚠️ SIGNAL CONFLICT: {symbol} BUY signal generated but H1 trend is {trend_name}")
            return False
        
        if signal_side == "SELL" and trend != -1:
            self.issues.append(f"⚠️ SIGNAL CONFLICT: {symbol} SELL signal generated but H1 trend is {trend_name}")
            return False
        
        return True
    
    def check_account_risk(self, positions: list, account_balance: float, magic: int) -> bool:
        """
        VULNERABILITY: Total open risk exceeds 10% of account
        Risk: Drawdown can wipe significant portion of account
        """
        auto_pos = [p for p in positions if p.magic == magic]
        if not auto_pos:
            return True
        
        total_risk = 0.0
        for pos in auto_pos:
            entry = float(pos.price_open)
            sl = float(pos.sl)
            sl_dist = abs(sl - entry)
            position_size = float(pos.volume)
            # Approximate risk = position size * SL distance (in pips, convert to USD)
            position_risk = position_size * sl_dist * 10  # Rough estimate
            total_risk += position_risk
        
        risk_pct = (total_risk / account_balance) * 100 if account_balance > 0 else 0
        
        if risk_pct > 10.0:
            self.issues.append(f"⚠️ ACCOUNT RISK: Total open risk is {risk_pct:.2f}% of account balance")
            return False
        
        return True
    
    def log_issues(self):
        """Log all found issues to logger"""
        if self.issues:
            for issue in self.issues:
                self.log.warning(issue)
        else:
            self.log.debug("✅ No vulnerabilities detected")
    
    def clear_issues(self):
        """Clear issue list for next check"""
        self.issues = []
